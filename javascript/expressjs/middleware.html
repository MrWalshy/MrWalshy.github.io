
<h1>Introduction to middleware in Express 4</h1>
<p><strong>Middleware</strong> is some software module that facilitates some operations and/or communication between other software modules. In Express, middleware functions are commonly used which have access to:</p>
<ul>
  <li>the request object</li>
  <li>the response object</li>
  <li>the next middleware function in the app's request-response cycle</li>
</ul>
<hr>
<h2>Applying middleware in Express</h2>
<p>Express applications are built up using a series of middleware function calls to handle the request-response cycle. This middleware may be of any of the following:</p>
<ul>
  <li>application-level</li>
  <li>router-level</li>
  <li>error-handling</li>
  <li>built-in</li>
  <li>third-party</li>
</ul>
<h3>Application-level middleware</h3>
<p>Application-level middleware is bound to an express application instance using the <code>app.use()</code> and <code>app.METHOD()</code> functions.</p>
<p>When creating a route in the application, a callback is specified as middleware to the relevant <code>app.METHOD()</code> function:</p>
<pre><code class="language-js">app.get('/', (req, res) => {
    res.send('GET');
});
</code></pre>
<p>This piece of middleware is called when a request is sent to the root path, <code>'/'</code>.</p>
<p>Usually, we also specify a third parameter in middleware functions, <code>next</code>, which represents a callback function of middleware to call after this function is done. For example, to create a piece of middleware which logs every request and information about it, we could create the following function:</p>
<pre><code class="language-js">function logger(req, res, next) {
    console.log(`${req.method} ${req.path}`);
    next();
};
</code></pre>
<blockquote>
  <p>The <code>next</code> parameter must be specified and called in this instance as we do not terminate the request, this accepts the next piece of middleware to run in the request-response cycle to prevent the request hanging.</p>
</blockquote>
<p>The callback function can then be passed to <code>app.use()</code> to specify this is middleware to run on every inbound request:</p>
<pre><code class="language-js">const express = require('express');

const port = 3000;
const app = express();

function logger(req, res, next) {
    console.log(`${req.method} ${req.path}`);
    next();
}

app.use(logger);
</code></pre>
<p>It is important to consider the order of how middleware is added as middleware added first will run first.</p>
<p>Middleware can also be specified to run on a specified route using <code>app.use()</code> as follows:</p>
<pre><code class="language-js">app.use('/user', logger);
</code></pre>
<p>This example specifies the <code>'/user'</code> path as the first parameter to <code>app.use()</code>, the logger is the handler function acting as middleware. The logger function will now only be called on requests to the <code>/user</code> route.</p>
<p>We can also specify multiple callback functions to the <code>app.use()</code> and <code>app.METHOD()</code> functions, for example the following specifies the logger function on the <code>/user</code> route and a callback for what to do:</p>
<pre><code class="language-js">app.get('/user', logger, (req, res, next) => {
        const page = req.query.page;
        const pageSize = req.query.pageSize;
        const output = `Returning page ${page} consisting of ${pageSize} users`;
        console.log(output);
        next();
    }, (req, res, next) => {
        res.send([{"name": "fred123"}]);
    }
);
</code></pre>
<p>On line 1, the path argument is specified followed by the <code>logger</code> middleware function next. When a request is inbound, the <code>logger</code> middleware will run first, it will then pass control to the callback function (3rd argument) which logs the query parameters for <code>page</code> and <code>pageSize</code> to the Node.js console. The callback then calls <code>next()</code> on line 6 to call the final callback (4th argument) specified on line 7, which sends the response back to the client.</p>
<h3>Router-level middleware</h3>
<p><strong>Router-level middleware</strong> works like application-level middleware, but is instead bound to an instance of <code>express.Router()</code>. Instead of using the <code>app.use()</code> and <code>app.METHOD()</code> methods to apply middleware, <code>router.use()</code> and <code>router.METHOD()</code> methods are used.</p>
<p>The following example demonstrates using middleware at the router-level:</p>
<pre><code class="language-js">const express = require('express');

const port = 3000;
const app = express();
const router = express.Router();

const users = [{"id": 1, "name": "fred123"}, {"id": 2, "name": "fred234"}];

function logger(req, res, next) {
    console.log(`${Date()} - ${req.method} ${req.path}`);
    next();
}

// no mount path, executed on every request to the router
router.use(logger);

router.get('/user', (req, res) => {
    res.status(200).send(users);
});

router.get('/user/:id', (req, res) => {
    const id = req.params.id;
    const user = users.find(user => user.id == id);
    if (user) {
        res.status(200).send(user);
        return;
    }
    res.status(404).send(`User with id ${id} not found.`);
});

// mount router
app.use('/', router);

const server = app.listen(port, () => {
    console.log(`Server up on ${server.address().address}:${port}`);
});
</code></pre>
<p>The example allows either a whole collection of users to be returned, or a single user from that collection. The major differences from the application-level examples are:</p>
<ul>
  <li>line 5: creating an instance of <code>express.Router()</code></li>
  <li>line 15,17,21: all use <code>router</code> instead of <code>app</code> to create endpoints</li>
  <li>line 32: mounts the <code>router</code> instance on the express <code>app</code></li>
</ul>
<h3>Error-handling middleware</h3>
<p><strong>Error-handling middleware</strong> functions like the other middleware functions seen so far, the major difference being that four arguments are required instead of three in the callback functions:</p>
<pre><code class="language-js">app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).send('Oops, something went wrong...');
});
</code></pre>
<blockquote>
  <p>If the <code>err</code> parameter is not specified, the callback will be treated like regular middleware and will not handle errors if used. Ensure the <code>err</code> parameter is specified for error-handling middleware!</p>
</blockquote>
<p>Taking lines 31 - 36 from the previous example in <strong>Router-level middleware</strong>, the above error-handling middleware is usually added to the middleware stack after the router.</p>
<pre><code class="language-js">// mount router
app.use('/', router);

// error handling if router bindings can't handle request or something else goes wrong
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).send('Oops, something went wrong...');
});

const server = app.listen(port, () => {
    console.log(`Server up on ${server.address().address}:${port}`);
});
</code></pre>
<h3>Built-in middleware</h3>
<p>Express includes built-in middleware functions for the most common behaviours in web applications:</p>
<ul>
  <li><code>express.static</code>: for serving static assets, i.e., html files, images, etc...</li>
  <li><code>express.json</code>: for parsing incoming requests with JSON payloads</li>
  <li><code>express.urlencoded</code>: for parsing incoming requests with URL-encoded payloads</li>
</ul>
<h3>Third-party middleware</h3>
<p>Third-party middleware functions can also be added to Express servers, a list of common middleware exists here: <code>https://expressjs.com/en/resources/middleware.html</code></p>
